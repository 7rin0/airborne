{"name":"Airborne","tagline":"RSpec driven API testing framework","body":"# Airborne\r\n\r\n[![airborne travis](http://img.shields.io/travis/brooklynDev/airborne.svg?branch=master&style=flat-square)](https://travis-ci.org/brooklynDev/airborne)\r\n[![airborne coveralls](http://img.shields.io/coveralls/brooklynDev/airborne/master.svg?style=flat-square)](https://coveralls.io/r/brooklynDev/airborne?branch=master)\r\n[![airborne gem version](http://img.shields.io/gem/v/airborne.svg?style=flat-square)](http://rubygems.org/gems/airborne)\r\n[![airbore gem downloads](http://img.shields.io/gem/dt/airborne.svg?style=flat-square)](http://rubygems.org/gems/airborne)\r\n[![airborne gem stable downloads](http://img.shields.io/gem/dv/airborne/stable.svg?style=flat-square)](http://rubygems.org/gems/airborne)\r\n\r\nRSpec driven API testing framework inspired by [frisby.js](https://github.com/vlucas/frisby)\r\n\r\n## Installation\r\n\r\nInstall Airborne:\r\n\r\n    gem install airborne\r\n    \r\nOr add it to your Gemfile:\r\n\r\n    gem 'airborne'\r\n\r\n##Creating Tests\r\n\r\n```ruby\r\nrequire 'airborne'\r\n\r\ndescribe 'sample spec' do\r\n  it 'should validate types' do\r\n    get 'http://example.com/api/v1/simple_get' #json api that returns { \"name\" : \"John Doe\" } \r\n    expect_json_types({name: :string})\r\n  end\r\n\r\n  it 'should validate values' do \r\n    get 'http://example.com/api/v1/simple_get' #json api that returns { \"name\" : \"John Doe\" } \r\n    expect_json({:name => \"John Doe\"})\r\n  end\r\nend\r\n```\r\n\r\nWhen calling expect_json_types, these are the valid types that can be tested against:\r\n\r\n* `:int` or `:integer`\r\n* `:float`\r\n* `:bool` or `:boolean`\r\n* `:string`\r\n* `:object`\r\n* `:array`\r\n* `:array_of_integers` or `:array_of_ints`\r\n* `:array_of_floats`\r\n* `:array_of_strings`\r\n* `:array_of_booleans` or `:array_of_bools`\r\n* `:array_of_objects`\r\n* `:array_of_arrays`\r\n\r\nIf the properties are optional and may not appear in the response, you can append `_or_null` to the types above.\r\n    \r\n```ruby\r\ndescribe 'sample spec' do\r\n  it 'should validate types' do\r\n    get 'http://example.com/api/v1/simple_get' #json api that returns { \"name\" : \"John Doe\" } or { \"name\" : \"John Doe\", \"age\" : 45 }\r\n    expect_json_types({name: :string, age: :int_or_null})\r\n  end\r\nend\r\n```\r\n\r\nAdditionally, if an entire object could be null, but you'd still want to test the types if it does exist, you can wrap the expectations in a call to `optional`:\r\n\r\n```ruby\r\nit 'should allow optional nested hash' do\r\n  get '/simple_path_get' #may or may not return coordinates\r\n  expect_json_types(\"address.coordinates\", optional({latitude: :float, longitude: :float}))\r\nend\r\n```\r\n\r\nAdditionally, when calling `expect_json`, you can provide a regex pattern in a call to `regex`:\r\n\r\n```ruby\r\ndescribe 'sample spec' do\r\n  it 'should validate types' do\r\n    get 'http://example.com/api/v1/simple_get' #json api that returns { \"name\" : \"John Doe\" }\r\n    expect_json({name: regex(\"^John\")})\r\n  end\r\nend\r\n```\r\n\r\nWhen calling `expect_json` or `expect_json_types`, you can optionally provide a block and run your own `rspec` expectations:\r\n\r\n```ruby\r\ndescribe 'sample spec' do\r\n  it 'should validate types' do\r\n    get 'http://example.com/api/v1/simple_get' #json api that returns { \"name\" : \"John Doe\" }\r\n    expect_json({name: -> (name){expect(name.length).to eq(8)}})\r\n  end\r\nend\r\n```\r\n\r\n##Making requests\r\n\r\nAirborne uses `rest_client` to make the HTTP request, and supports all HTTP verbs. When creating a test, you can call any of the following methods: `get`, `post`, `put`, `patch`, `delete`. This will then give you access the following properties:\r\n\r\n* `response` - The HTTP response returned from the request\r\n* `headers` - A symbolized hash of the response headers returned by the request\r\n* `body` - The raw HTTP body returned from the request\r\n* `json_body` - A symbolized hash representation of the JSON returned by the request\r\n\r\nFor example:\r\n\r\n```ruby\r\nit 'should validate types' do\r\n  get 'http://example.com/api/v1/simple_get' #json api that returns { \"name\" : \"John Doe\" } \r\n  name = json_body[:name] #name will equal \"John Doe\"\r\n  body_as_string = body\r\nend\r\n```\r\n\r\nWhen calling any of the methods above, you can pass request headers to be used. \r\n\r\n```ruby\r\nget 'http://example.com/api/v1/my_api', {'x-auth-token' => 'my_token'}\r\n```\r\n\r\nFor requests that require a body (`post`, `put`, `patch`) you can pass the body as a hash as well:\r\n    \r\n```ruby\r\npost 'http://example.com/api/v1/my_api', {:name => 'John Doe'}, {'x-auth-token' => 'my_token'}\r\n```\r\n\r\n##Testing Rack Applications\r\n\r\nIf you have an existing Rack application like `sinatra` or `grape` you can run Airborne against your application and test without actually having a server running. To do that, just specify your rack application in your Airborne configuration:\r\n\r\n```ruby\r\nAirborne.configure do |config|\r\n    config.rack_app = MySinatraApp\r\nend\r\n```\r\n\r\nUnder the covers, Airborne uses [rack-test](https://github.com/brynary/rack-test) to make the requests. (Rails applications are still not working correctly, support for Rails will come soon!)\r\n  \r\n##API\r\n\r\n* `expect_json_types` - Tests the types of the JSON property values returned\r\n* `expect_json` - Tests the values of the JSON property values returned\r\n* `expect_json_keys` - Tests the existence of the specified keys in the JSON object\r\n* `expect_status` - Tests the HTTP status code returned\r\n* `expect_header` - Tests for a specified header in the response\r\n* `expect_header_contains` - Partial match test on a specified header\r\n\r\n##Path Matching\r\n\r\nWhen calling `expect_json_types`, `expect_json` or `expect_json_keys` you can optionally specify a path as a first parameter. \r\n\r\nFor example, if our API returns the following JSON:\r\n\r\n```json\r\n{\r\n  \"name\": \"Alex\",\r\n  \"address\": {\r\n    \"street\": \"Area 51\",\r\n    \"city\": \"Roswell\",\r\n    \"state\": \"NM\",\r\n    \"coordinates\": {\r\n      \"latitude\": 33.3872,\r\n      \"longitude\": 104.5281\r\n    }\r\n  }\r\n}\r\n```\r\n    \r\nThis test would only test the address object:\r\n    \r\n```ruby\r\ndescribe 'path spec' do\r\n  it 'should allow simple path and verify only that path' do\r\n    get 'http://example.com/api/v1/simple_path_get'\r\n    expect_json_types('address', {street: :string, city: :string, state: :string, coordinates: :object })\r\n    #or this\r\n    expect_json_types('address', {street: :string, city: :string, state: :string, coordinates: { latitude: :float, longitude: :float } })\r\n  end\r\nend\r\n```\r\nOr, to test the existence of specific keys:\r\n\r\n```ruby\r\nit 'should allow nested paths' do\r\n  get 'http://example.com/api/v1/simple_path_get'\r\n  expect_json_keys('address', [:street, :city, :state, :coordinates])    \r\nend\r\n```\r\n\r\nAlternativley, if we only want to test `coordinates` we can dot into just the `coordinates`:\r\n\r\n```ruby\r\nit 'should allow nested paths' do\r\n  get 'http://example.com/api/v1/simple_path_get'\r\n  expect_json('address.coordinates', {latitude: 33.3872, longitude: 104.5281} )     \r\nend\r\n```\r\n\r\nWhen dealing with `arrays`, we can optionally test all (`*`) or a single (`?` - any, `0` - index) element of the array:\r\n\r\nGiven the following JSON:\r\n\r\n```json\r\n{\r\n  \"cars\": [\r\n    {\r\n      \"make\": \"Tesla\",\r\n      \"model\": \"Model S\"\r\n    },\r\n    {\r\n      \"make\": \"Lamborghini\",\r\n      \"model\": \"Aventador\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nWe can test against just the first car like this:\r\n\r\n```ruby\r\nit 'should index into array and test against specific element' do \r\n  get '/array_api'\r\n  expect_json('cars.0', {make: \"Tesla\", model: \"Model S\"})\r\nend\r\n```\r\n\r\nTo test the types of all elements in the array:\r\n\r\n```ruby\r\nit 'should test all elements of the array' do \r\n  get 'http://example.com/api/v1/array_api'\r\n  expect_json('cars.?', {make: \"Tesla\", model: \"Model S\"}) # tests that one car in array matches the tesla\r\n  expect_json_types('cars.*', {make: :string, model: :string}) # tests all cars in array for make and model of type string\r\nend\r\n```\r\n    \r\n`*` and `?` work for nested arrays as well. Given the following JSON:\r\n\r\n```json\r\n{\r\n  \"cars\": [\r\n    {\r\n      \"make\": \"Tesla\",\r\n      \"model\": \"Model S\",\r\n      \"owners\": [\r\n        {\r\n          \"name\": \"Bart Simpson\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"make\": \"Lamborghini\",\r\n      \"model\": \"Aventador\",\r\n      \"owners\": [\r\n        {\r\n          \"name\": \"Peter Griffin\"\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n===\r\n\r\n```ruby\r\nit 'should check all nested arrays for specified elements' do\r\n  get 'http://example.com/api/v1/array_with_nested'\r\n  expect_json_types('cars.*.owners.*', {name: :string})\r\nend\r\n```\r\n\r\n##Configuration\r\n\r\nWhen setting up Airborne, you can call `configure` just like you would with `rspec`:\r\n\r\n```ruby\r\n#config is the RSpec configuration and can be used just like it\r\nAirborne.configure.do |config|\r\n  config.include MyModule\r\nend\r\n```\r\n\r\nAdditionally, you can specify a `base_url` and default `headers` to be used on every request (unless overridden in the actual request):\r\n\r\n```ruby\r\nAirborne.configure.do |config|\r\n  config.base_url = 'http://example.com/api/v1'\r\n  config.headers = {'x-auth-token' => 'my_token'}\r\nend\r\n\r\ndescribe 'spec' do\r\n  it 'now we no longer need the full url' do\r\n    get '/simple_get'\r\n    expect_json_types({name: :string})\r\n  end\r\nend\r\n```\r\n\r\n### Run it from the CLI\r\n\r\n    $ cd your/project\r\n    $ rspec spec\r\n    \r\n## License \r\n\r\nThe MIT License\r\n\r\nCopyright (c) 2014 brooklyndev, sethpollack\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}